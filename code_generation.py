from typing import TypeVar, Type, Generic

from binary_representation import build_binary_orientation_spec, permutation_to_bitwise_ops, StickerBinarySerializer, \
    IntSerializer, IntSpec, build_cube3_to_cube2_bitwise_ops
from cube2.cube import Cube2
from cube3.cube import Cube3
from utils import compute_stickers_permutation, CubiesCube, cube_with_unique_sticker_codes


T = TypeVar("T", bound=CubiesCube)


class CodeGenerator(Generic[T]):

    def __init__(self, cube_class: Type[T]) -> None:
        self.cube_class = cube_class
        self.binary_serializer = StickerBinarySerializer(cube_class)
        self.int_serializer = IntSerializer(self.binary_serializer)
        self.solved_cube_binary = self.binary_serializer.serialize(self.solved_cube)
        self.solved_cube_int = self.int_serializer.serialize(self.solved_cube)
        super().__init__()

    @property
    def int_spec(self):
        return IntSpec.for_cube(self.cube_class)

    @property
    def solved_cube(self):
        return self.cube_class()

    def build(self):
        bitwise_shifts = compute_stickers_bitwise_shifts_per_operation(self.cube_class)
        moves_fn_names = list(bitwise_shifts.keys())
        fixed_cubie_fn_names = [move for move in moves_fn_names if move not in ["RU", "RD", "DR", "DL", "FR", "FL"]]
        return "\n".join([
            self.build_autogenerated_comment(),
            self.build_cube3_to_cube2(build_cube3_to_cube2_bitwise_ops()),
            self.build_cube_orientation_code(build_binary_orientation_spec(self.cube_class)),
            self.build_operations_code(bitwise_shifts),
            self.build_main_function(moves_fn_names, fixed_cubie_fn_names),
        ])

    def build_autogenerated_comment(self):
        raise NotImplementedError()

    def build_cube_orientation_code(self, orientation_spec):
        raise NotImplementedError()

    def build_operations_code(self, bitwise_shifts_per_op):
        raise NotImplementedError()

    def build_cube3_to_cube2(self, shift_spec):
        raise NotImplementedError()

    def build_main_function(self, moves_fn_names, fixed_cubie_fn_names):
        raise NotImplementedError()


class PythonCodeGenerator(CodeGenerator):

    def build_autogenerated_comment(self):
        return """'''
This file was auto-generated, do not change manually
'''"""

    def build_cube3_to_cube2(self, shift_spec):
        shifts = stringify_bitwise_shifts(shift_spec)
        return f'''
def cube3_to_cube2(x):
    return {shifts}

'''

    def build_cube_orientation_code(self, definitions):
        code = []
        code.append("""
def orient_cube(x:int):""")
        for cubie, definitions in definitions.items():
            actual_color_pattern = stringify_bitwise_shifts(definitions[0]['color_detection_bitwise_lhs'])
            code.append(f'    # Cubie {cubie}')
            code.append(f'    actual_color_pattern = {actual_color_pattern}')
            for definition in definitions:
                oriented_cube = stringify_bitwise_shifts(definition['orient_cube_bitwise_op'])
                code.append(f'    if actual_color_pattern == {definition["color_detection_bitwise_rhs"]}:')
                code.append(f'        return {oriented_cube}')
        code.append('    raise Exception("State {0} was not possible to orient to fix cubie in place".format(x))')
        return "\n".join(code)


    def build_operations_code(self, bitwise_shifts):
        code = []
        ops = list(bitwise_shifts.items())
        for name, shifts in ops:
            code.append(f"""
def {name.lower()}(x):
    return {stringify_bitwise_shifts(shifts)}
    """)
        return "\n".join(code)

    def build_main_function(self, moves_fn_names, fixed_cubie_fn_names):
        return f"""
OPS = [{(", ".join(moves_fn_names)).lower()}]
OPS_DICT = {{fn.__name__: fn for fn in OPS}}
FIXED_CUBIE_OPS = [{(", ".join(fixed_cubie_fn_names)).lower()}]
FIXED_CUBIE_OPS_DICT = {{fn.__name__: fn for fn in FIXED_CUBIE_OPS}}
SOLVED_CUBE_STATE = {self.solved_cube_int}
def main():
    pass
    """


class RustCodeGenerator(CodeGenerator):

    @property
    def int_type(self):
        return 'i%d' % self.int_spec.int_size

    def build_cube3_to_cube2(self, shift_spec):
        cube3_spec = IntSpec.for_cube(Cube3)
        cube2_spec = IntSpec.for_cube(Cube2)
        shifts = stringify_bitwise_shifts(shift_spec)
        return f'''
fn cube3_to_cube2(x: i{cube3_spec.int_size}) -> i{cube2_spec.int_size} {{
    return ({shifts}) as i{cube2_spec.int_size};
}}
'''

    def build_autogenerated_comment(self):
        return "// This file was auto-generated, do not change manually"

    def build_cube_orientation_code(self, definitions):
        code = []
        code.append(f"""
fn orient_cube(x: {self.int_type}) -> {self.int_type} {{""")
        code.append(f'    let mut actual_color_pattern: {self.int_type};')
        for cubie, definitions in definitions.items():
            actual_color_pattern = stringify_bitwise_shifts(definitions[0]['color_detection_bitwise_lhs'])
            code.append(f'    actual_color_pattern = {actual_color_pattern};')
            for definition in definitions:
                oriented_cube = stringify_bitwise_shifts(definition['orient_cube_bitwise_op'])
                code.append(f'    if actual_color_pattern == {definition["color_detection_bitwise_rhs"]} {{')
                code.append(f'        return {oriented_cube};')
                code.append(f'    }}')
        code.append('    panic!("State was not possible to orient: {}", x);')
        code.append(f'}}')
        return "\n".join(code)

    def build_operations_code(self, bitwise_shifts):
        code = []
        for name, shifts in bitwise_shifts.items():
            code.append(f"""
fn {name.lower()}(x: {self.int_type}) -> {self.int_type} {{
    return {stringify_bitwise_shifts(shifts)};
}}""")
        return "\n".join(code)

    def build_main_function(self, moves_fn_names, fixed_cubie_fn_names):
        return f"""
// self.solved_cube_binary
static ALL_OPERATIONS: &'static [fn(i128) -> i128] = &[{(", ".join(moves_fn_names)).lower()}];
static FIXED_CUBIE_OPERATIONS: &'static [fn(i128) -> i128] = &[{(", ".join(fixed_cubie_fn_names)).lower()}];

fn main() {{
    let solved_state:i64 = {hex(self.solved_cube_int)};
}}
    """


def compute_stickers_bitwise_shifts_per_operation(cube_class: Type[T]):
    unique_cube = cube_with_unique_sticker_codes(cube_class)

    bitwise_shifts = {}
    for name, op in cube_class.OPERATIONS.items():
        permutation = compute_stickers_permutation(op(unique_cube), unique_cube)
        bitwise_shifts[name] = permutation_to_bitwise_ops(permutation, IntSpec.for_cube(cube_class))
    return bitwise_shifts


def stringify_bitwise_shifts(shifts):
    as_str = []
    for offset, mask in shifts.items():
        direction = '>>' if offset < 0 else '<<'
        as_str.append(f'((x & {hex(mask)}) {direction} {abs(offset)})')
    return "|".join(as_str)
