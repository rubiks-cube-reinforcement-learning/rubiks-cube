from typing import TypeVar, Type, Generic

from binary_representation import build_binary_orientation_spec, permutation_to_bitwise_ops, StickerBinarySerializer, \
    IntSerializer, IntSpec
from cube2.cube import OPERATIONS
from utils import compute_stickers_permutation, CubiesCube, cube_with_unique_sticker_codes


T = TypeVar("T", bound=CubiesCube)


class CodeGenerator(Generic[T]):

    def __init__(self, cube_class: Type[T]) -> None:
        self.cube_class = cube_class
        self.binary_serializer = StickerBinarySerializer(cube_class)
        self.int_serializer = IntSerializer(self.binary_serializer)
        self.solved_cube_binary = self.binary_serializer.serialize(self.solved_cube)
        self.solved_cube_int = self.int_serializer.serialize(self.solved_cube)
        super().__init__()

    @property
    def solved_cube(self):
        return self.cube_class()

    def print(self):
        self.print_autogenerated_comment()
        self.print_cube_orientation_code(build_binary_orientation_spec(self.cube_class))
        moves_fn_names = self.print_operations_code(compute_stickers_bitwise_shifts_per_operation(self.cube_class))
        self.print_main_function(moves_fn_names)

    def print_autogenerated_comment(self):
        raise NotImplementedError()

    def print_cube_orientation_code(self, orientation_spec):
        raise NotImplementedError()

    def print_operations_code(self, bitwise_shifts_per_op):
        raise NotImplementedError()

    def print_main_function(self, moves_fn_names):
        raise NotImplementedError()


class PythonCodeGenerator(CodeGenerator):

    def print_autogenerated_comment(self):
        print("""'''
This file was auto-generated, do not change manually
'''""")

    def print_cube_orientation_code(self, definitions):
        print("""
def orient_cube(x:int):""")
        for cubie, definitions in definitions.items():
            actual_color_pattern = stringify_bitwise_shifts(definitions[0]['color_detection_bitwise_lhs'])
            print(f'    # Cubie {cubie}')
            print(f'    actual_color_pattern = {actual_color_pattern}')
            for definition in definitions:
                oriented_cube = stringify_bitwise_shifts(definition['orient_cube_bitwise_op'])
                print(f'    if actual_color_pattern == {definition["color_detection_bitwise_rhs"]}:')
                print(f'        return {oriented_cube}')
        print('    raise Exception("State {0} was not possible to orient to fix cubie 4 in place".format(x))')


    def print_operations_code(self, bitwise_shifts):
        moves_fn_names = []
        ops = list(bitwise_shifts.items())
        for name, shifts in ops:
            print(f"""
    def {name.lower()}(x):
        return {stringify_bitwise_shifts(shifts)}
    """)
            moves_fn_names.append(name)
        return moves_fn_names

    def print_main_function(self, moves_fn_names):
        ops_str = (", ".join(moves_fn_names)).lower()

        print(f"""
    from cubies import *
    from random import shuffle
    def main():
        OPS = [{ops_str}]
        SOLVED_CUBE_INT = {self.solved_cube_int}
        print(SOLVED_CUBE_INT)
        current = SOLVED_CUBE_INT
        test = ru(SOLVED_CUBE_INT)
        print(test)
        print(orient_cube(test))
        for op in OPS:
            shuffle(OPS)
        #     for i in range(10):
        #         current = op(current)
        #     c = IntSerializer(StickerBinarySerializerZ()).unserialize(current)
        #     is_valid = c.assert_valid()
    
    main()
    """)


class RustCodeGenerator(CodeGenerator):

    @property
    def int_type(self):
        return 'i%d' % IntSpec.for_cube(self.cube_class).int_size

    def print_autogenerated_comment(self):
        print("// This file was auto-generated, do not change manually")

    def print_cube_orientation_code(self, definitions):
        print(f"""
fn orient_cube(x: {self.int_type}) -> {self.int_type} {{""")
        print(f'    let mut actual_color_pattern: {self.int_type};')
        for cubie, definitions in definitions.items():
            actual_color_pattern = stringify_bitwise_shifts(definitions[0]['color_detection_bitwise_lhs'])
            print(f'    actual_color_pattern = {actual_color_pattern};')
            for definition in definitions:
                oriented_cube = stringify_bitwise_shifts(definition['orient_cube_bitwise_op'])
                print(f'    if actual_color_pattern == {definition["color_detection_bitwise_rhs"]} {{')
                print(f'        return {oriented_cube};')
                print(f'    }}')
        print('    panic!("State was not possible to orient: {}", x);')
        print(f'}}')

    def print_operations_code(self, bitwise_shifts):
        moves_fn_names = []
        for name, shifts in bitwise_shifts.items():
            print(f"""
fn {name.lower()}(x: {self.int_type}) -> {self.int_type} {{
    return {stringify_bitwise_shifts(shifts)};
}}""")
            moves_fn_names.append(name)

        return moves_fn_names

    def print_main_function(self, moves_fn_names):
        print("// self.solved_cube_binary")
        print(f"""
fn main() {{
    let solved_state:i64 = {hex(self.solved_cube_int)};
}}
    """)


def compute_stickers_bitwise_shifts_per_operation(cube_class: Type[T]):
    unique_cube = cube_with_unique_sticker_codes(cube_class)

    bitwise_shifts = {}
    for name, op in OPERATIONS.items():
        permutation = compute_stickers_permutation(op(unique_cube), unique_cube)
        bitwise_shifts[name] = permutation_to_bitwise_ops(permutation, IntSpec.for_cube(cube_class))
    return bitwise_shifts


def stringify_bitwise_shifts(shifts):
    as_str = []
    for offset, mask in shifts.items():
        direction = '>>' if offset < 0 else '<<'
        as_str.append(f'((x & {hex(mask)}) {direction} {abs(offset)})')
    return "|".join(as_str)
